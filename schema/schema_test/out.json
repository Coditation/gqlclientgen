{
	"Query": {
		"Kind": "OBJECT",
		"Description": "",
		"Name": "Query",
		"Directives": null,
		"Interfaces": null,
		"Fields": [
			{
				"Description": "",
				"Name": "objects",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 999,
								"End": 1000,
								"Line": 82,
								"Column": 28,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 982,
							"End": 994,
							"Line": 82,
							"Column": 11,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "",
					"Elem": {
						"NamedType": "Object",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1003,
							"End": 1009,
							"Line": 82,
							"Column": 32,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"NonNull": true,
					"Position": {
						"Start": 1014,
						"End": 1026,
						"Line": 83,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 974,
					"End": 981,
					"Line": 82,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "objectRecord",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1046,
								"End": 1050,
								"Line": 83,
								"Column": 35,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1027,
							"End": 1039,
							"Line": 83,
							"Column": 16,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "name",
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1061,
								"End": 1063,
								"Line": 83,
								"Column": 50,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1046,
							"End": 1050,
							"Line": 83,
							"Column": 35,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "id",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1068,
								"End": 1069,
								"Line": 83,
								"Column": 57,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1061,
							"End": 1063,
							"Line": 83,
							"Column": 50,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "ObjectRecord",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1087,
						"End": 1091,
						"Line": 84,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1014,
					"End": 1026,
					"Line": 83,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "soql",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1111,
								"End": 1112,
								"Line": 84,
								"Column": 27,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1092,
							"End": 1104,
							"Line": 84,
							"Column": 8,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "q",
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1123,
								"End": 1128,
								"Line": 84,
								"Column": 39,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1111,
							"End": 1112,
							"Line": 84,
							"Column": 27,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "PageInput",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1140,
								"End": 1141,
								"Line": 84,
								"Column": 56,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1123,
							"End": 1128,
							"Line": 84,
							"Column": 39,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "QueryResult",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1158,
						"End": 1164,
						"Line": 85,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1087,
					"End": 1091,
					"Line": 84,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "health",
				"Arguments": null,
				"DefaultValue": null,
				"Type": {
					"NamedType": "ConnectorHealth",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1183,
						"End": 1184,
						"Line": 86,
						"Column": 1,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1158,
					"End": 1164,
					"Line": 85,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "__schema",
				"Arguments": null,
				"DefaultValue": null,
				"Type": {
					"NamedType": "__Schema",
					"Elem": null,
					"NonNull": true,
					"Position": null
				},
				"Directives": null,
				"Position": null
			},
			{
				"Description": "",
				"Name": "__type",
				"Arguments": [
					{
						"Description": "",
						"Name": "name",
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": null
						},
						"Directives": null,
						"Position": null
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "__Type",
					"Elem": null,
					"NonNull": false,
					"Position": null
				},
				"Directives": null,
				"Position": null
			}
		],
		"Types": null,
		"EnumValues": null,
		"Position": {
			"Start": 964,
			"End": 969,
			"Line": 81,
			"Column": 6,
			"Src": {
				"Name": "default",
				"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
				"BuiltIn": false
			}
		},
		"BuiltIn": false
	},
	"Mutation": {
		"Kind": "OBJECT",
		"Description": "",
		"Name": "Mutation",
		"Directives": null,
		"Interfaces": null,
		"Fields": [
			{
				"Description": "",
				"Name": "registerConnection",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1242,
								"End": 1247,
								"Line": 89,
								"Column": 41,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1223,
							"End": 1235,
							"Line": 89,
							"Column": 22,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "AuthInfoInput",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1249,
								"End": 1262,
								"Line": 89,
								"Column": 48,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1242,
							"End": 1247,
							"Line": 89,
							"Column": 41,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1265,
						"End": 1268,
						"Line": 89,
						"Column": 64,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1204,
					"End": 1222,
					"Line": 89,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "revokeConnection",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1305,
								"End": 1306,
								"Line": 90,
								"Column": 37,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1288,
							"End": 1300,
							"Line": 90,
							"Column": 20,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1308,
						"End": 1311,
						"Line": 90,
						"Column": 40,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1271,
					"End": 1287,
					"Line": 90,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "createObjectRecord",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1360,
								"End": 1365,
								"Line": 93,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1338,
							"End": 1350,
							"Line": 92,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "NewObjectRecordInput",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1391,
								"End": 1392,
								"Line": 94,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1360,
							"End": 1365,
							"Line": 93,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "ObjectRecord",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1410,
						"End": 1428,
						"Line": 95,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1314,
					"End": 1332,
					"Line": 91,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "updateObjectRecord",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1456,
								"End": 1458,
								"Line": 97,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1434,
							"End": 1446,
							"Line": 96,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "id",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1468,
								"End": 1473,
								"Line": 98,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1456,
							"End": 1458,
							"Line": 97,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "UpdateObjectRecordInput",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1502,
								"End": 1503,
								"Line": 99,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1468,
							"End": 1473,
							"Line": 98,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "ObjectRecord",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1521,
						"End": 1543,
						"Line": 100,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1410,
					"End": 1428,
					"Line": 95,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "onObjectRecordsCreated",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1571,
								"End": 1576,
								"Line": 102,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1549,
							"End": 1561,
							"Line": 101,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "OnCreatedObjectInput",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1600,
									"End": 1601,
									"Line": 102,
									"Column": 34,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 1605,
								"End": 1606,
								"Line": 103,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1571,
							"End": 1576,
							"Line": 102,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1608,
						"End": 1611,
						"Line": 103,
						"Column": 6,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1521,
					"End": 1543,
					"Line": 100,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "onObjectRecordsUpdated",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1664,
								"End": 1669,
								"Line": 106,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1642,
							"End": 1654,
							"Line": 105,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "input",
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "OnUpdatedObjectInput",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1693,
									"End": 1694,
									"Line": 106,
									"Column": 34,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 1698,
								"End": 1699,
								"Line": 107,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1664,
							"End": 1669,
							"Line": 106,
							"Column": 5,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1701,
						"End": 1704,
						"Line": 107,
						"Column": 6,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1614,
					"End": 1636,
					"Line": 104,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "pollForChange",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1738,
								"End": 1739,
								"Line": 108,
								"Column": 34,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1721,
							"End": 1733,
							"Line": 108,
							"Column": 17,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1741,
						"End": 1744,
						"Line": 108,
						"Column": 37,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1707,
					"End": 1720,
					"Line": 108,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "keepTokenAlive",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1779,
								"End": 1780,
								"Line": 109,
								"Column": 35,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1762,
							"End": 1774,
							"Line": 109,
							"Column": 18,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1782,
						"End": 1785,
						"Line": 109,
						"Column": 38,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1747,
					"End": 1761,
					"Line": 109,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "runIntegrationTests",
				"Arguments": null,
				"DefaultValue": null,
				"Type": {
					"NamedType": "Any",
					"Elem": null,
					"NonNull": false,
					"Position": {
						"Start": 1809,
						"End": 1812,
						"Line": 110,
						"Column": 24,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1788,
					"End": 1807,
					"Line": 110,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			}
		],
		"Types": null,
		"EnumValues": null,
		"Position": {
			"Start": 1191,
			"End": 1199,
			"Line": 88,
			"Column": 6,
			"Src": {
				"Name": "default",
				"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
				"BuiltIn": false
			}
		},
		"BuiltIn": false
	},
	"Subscription": {
		"Kind": "OBJECT",
		"Description": "",
		"Name": "Subscription",
		"Directives": null,
		"Interfaces": null,
		"Fields": [
			{
				"Description": "",
				"Name": "objectRecordsCreated",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1876,
								"End": 1877,
								"Line": 114,
								"Column": 41,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1859,
							"End": 1871,
							"Line": 114,
							"Column": 24,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "",
					"Elem": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1880,
							"End": 1892,
							"Line": 114,
							"Column": 45,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"NonNull": true,
					"Position": {
						"Start": 1897,
						"End": 1916,
						"Line": 115,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1838,
					"End": 1858,
					"Line": 114,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			},
			{
				"Description": "",
				"Name": "objectRecordUpdated",
				"Arguments": [
					{
						"Description": "",
						"Name": "connectionId",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1936,
								"End": 1940,
								"Line": 115,
								"Column": 42,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1917,
							"End": 1929,
							"Line": 115,
							"Column": 23,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "name",
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1951,
								"End": 1953,
								"Line": 115,
								"Column": 57,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1936,
							"End": 1940,
							"Line": 115,
							"Column": 42,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "id",
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1958,
								"End": 1959,
								"Line": 115,
								"Column": 64,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1951,
							"End": 1953,
							"Line": 115,
							"Column": 57,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"DefaultValue": null,
				"Type": {
					"NamedType": "ObjectRecord",
					"Elem": null,
					"NonNull": true,
					"Position": {
						"Start": 1975,
						"End": 1976,
						"Line": 116,
						"Column": 1,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				"Directives": null,
				"Position": {
					"Start": 1897,
					"End": 1916,
					"Line": 115,
					"Column": 3,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				}
			}
		],
		"Types": null,
		"EnumValues": null,
		"Position": {
			"Start": 1821,
			"End": 1833,
			"Line": 113,
			"Column": 6,
			"Src": {
				"Name": "default",
				"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
				"BuiltIn": false
			}
		},
		"BuiltIn": false
	},
	"Types": {
		"Any": {
			"Kind": "SCALAR",
			"Description": "",
			"Name": "Any",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 7,
				"End": 10,
				"Line": 1,
				"Column": 8,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"AuthInfoInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "AuthInfoInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "type",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 926,
							"End": 936,
							"Line": 77,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 910,
						"End": 914,
						"Line": 76,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 943,
							"End": 944,
							"Line": 78,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 926,
						"End": 936,
						"Line": 77,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 892,
				"End": 905,
				"Line": 75,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Boolean": {
			"Kind": "SCALAR",
			"Description": "The `Boolean` scalar type represents `true` or `false`.",
			"Name": "Boolean",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 723,
				"End": 730,
				"Line": 13,
				"Column": 8,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"ConnectorHealth": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "ConnectorHealth",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "status",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "HealthStatus",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 303,
							"End": 314,
							"Line": 28,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 279,
						"End": 285,
						"Line": 27,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "lastChecked",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Int",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 323,
							"End": 329,
							"Line": 29,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 303,
						"End": 314,
						"Line": 28,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "errors",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "HealthError",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 332,
								"End": 343,
								"Line": 29,
								"Column": 12,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 332,
							"End": 343,
							"Line": 29,
							"Column": 12,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 323,
						"End": 329,
						"Line": 29,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 259,
				"End": 274,
				"Line": 26,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Edge": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "Edge",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "cursor",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 863,
							"End": 867,
							"Line": 72,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 845,
						"End": 851,
						"Line": 71,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "node",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 883,
							"End": 884,
							"Line": 73,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 863,
						"End": 867,
						"Line": 72,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 836,
				"End": 840,
				"Line": 70,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Float": {
			"Kind": "SCALAR",
			"Description": "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).",
			"Name": "Float",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 453,
				"End": 458,
				"Line": 7,
				"Column": 8,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"HealthError": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "HealthError",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "test",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 234,
							"End": 241,
							"Line": 23,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 218,
						"End": 222,
						"Line": 22,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "message",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 251,
							"End": 252,
							"Line": 24,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 234,
						"End": 241,
						"Line": 23,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 202,
				"End": 213,
				"Line": 21,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"HealthStatus": {
			"Kind": "ENUM",
			"Description": "",
			"Name": "HealthStatus",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": [
				{
					"Description": "",
					"Name": "HEALTHY",
					"Directives": null,
					"Position": {
						"Start": 174,
						"End": 181,
						"Line": 17,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "UNHEALTHY",
					"Directives": null,
					"Position": {
						"Start": 184,
						"End": 193,
						"Line": 18,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Position": {
				"Start": 157,
				"End": 169,
				"Line": 16,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"ID": {
			"Kind": "SCALAR",
			"Description": "The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.",
			"Name": "ID",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 1074,
				"End": 1076,
				"Line": 16,
				"Column": 8,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"Int": {
			"Kind": "SCALAR",
			"Description": "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
			"Name": "Int",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 284,
				"End": 287,
				"Line": 4,
				"Column": 8,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"Map": {
			"Kind": "SCALAR",
			"Description": "",
			"Name": "Map",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 18,
				"End": 21,
				"Line": 2,
				"Column": 8,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Mutation": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "Mutation",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "registerConnection",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1242,
									"End": 1247,
									"Line": 89,
									"Column": 41,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1223,
								"End": 1235,
								"Line": 89,
								"Column": 22,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "AuthInfoInput",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 1249,
									"End": 1262,
									"Line": 89,
									"Column": 48,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1242,
								"End": 1247,
								"Line": 89,
								"Column": 41,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1265,
							"End": 1268,
							"Line": 89,
							"Column": 64,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1204,
						"End": 1222,
						"Line": 89,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "revokeConnection",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1305,
									"End": 1306,
									"Line": 90,
									"Column": 37,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1288,
								"End": 1300,
								"Line": 90,
								"Column": 20,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1308,
							"End": 1311,
							"Line": 90,
							"Column": 40,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1271,
						"End": 1287,
						"Line": 90,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "createObjectRecord",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1360,
									"End": 1365,
									"Line": 93,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1338,
								"End": 1350,
								"Line": 92,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "NewObjectRecordInput",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1391,
									"End": 1392,
									"Line": 94,
									"Column": 3,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1360,
								"End": 1365,
								"Line": 93,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1410,
							"End": 1428,
							"Line": 95,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1314,
						"End": 1332,
						"Line": 91,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "updateObjectRecord",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1456,
									"End": 1458,
									"Line": 97,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1434,
								"End": 1446,
								"Line": 96,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "id",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1468,
									"End": 1473,
									"Line": 98,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1456,
								"End": 1458,
								"Line": 97,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "UpdateObjectRecordInput",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1502,
									"End": 1503,
									"Line": 99,
									"Column": 3,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1468,
								"End": 1473,
								"Line": 98,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1521,
							"End": 1543,
							"Line": 100,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1410,
						"End": 1428,
						"Line": 95,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "onObjectRecordsCreated",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1571,
									"End": 1576,
									"Line": 102,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1549,
								"End": 1561,
								"Line": 101,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "",
								"Elem": {
									"NamedType": "OnCreatedObjectInput",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1600,
										"End": 1601,
										"Line": 102,
										"Column": 34,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"NonNull": true,
								"Position": {
									"Start": 1605,
									"End": 1606,
									"Line": 103,
									"Column": 3,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1571,
								"End": 1576,
								"Line": 102,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1608,
							"End": 1611,
							"Line": 103,
							"Column": 6,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1521,
						"End": 1543,
						"Line": 100,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "onObjectRecordsUpdated",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1664,
									"End": 1669,
									"Line": 106,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1642,
								"End": 1654,
								"Line": 105,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "",
								"Elem": {
									"NamedType": "OnUpdatedObjectInput",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1693,
										"End": 1694,
										"Line": 106,
										"Column": 34,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"NonNull": true,
								"Position": {
									"Start": 1698,
									"End": 1699,
									"Line": 107,
									"Column": 3,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1664,
								"End": 1669,
								"Line": 106,
								"Column": 5,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1701,
							"End": 1704,
							"Line": 107,
							"Column": 6,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1614,
						"End": 1636,
						"Line": 104,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "pollForChange",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1738,
									"End": 1739,
									"Line": 108,
									"Column": 34,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1721,
								"End": 1733,
								"Line": 108,
								"Column": 17,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1741,
							"End": 1744,
							"Line": 108,
							"Column": 37,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1707,
						"End": 1720,
						"Line": 108,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "keepTokenAlive",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1779,
									"End": 1780,
									"Line": 109,
									"Column": 35,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1762,
								"End": 1774,
								"Line": 109,
								"Column": 18,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1782,
							"End": 1785,
							"Line": 109,
							"Column": 38,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1747,
						"End": 1761,
						"Line": 109,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "runIntegrationTests",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Any",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1809,
							"End": 1812,
							"Line": 110,
							"Column": 24,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1788,
						"End": 1807,
						"Line": 110,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 1191,
				"End": 1199,
				"Line": 88,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"NewObjectRecordInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "NewObjectRecordInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 395,
							"End": 405,
							"Line": 34,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 379,
						"End": 383,
						"Line": 33,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 412,
							"End": 413,
							"Line": 35,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 395,
						"End": 405,
						"Line": 34,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 354,
				"End": 374,
				"Line": 32,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Object": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "Object",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 64,
							"End": 74,
							"Line": 7,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 48,
						"End": 52,
						"Line": 6,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 81,
							"End": 82,
							"Line": 8,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 64,
						"End": 74,
						"Line": 7,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 37,
				"End": 43,
				"Line": 5,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"ObjectRecord": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "ObjectRecord",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "id",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ID",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 116,
							"End": 120,
							"Line": 12,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 106,
						"End": 108,
						"Line": 11,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "type",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 132,
							"End": 142,
							"Line": 13,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 116,
						"End": 120,
						"Line": 12,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 149,
							"End": 150,
							"Line": 14,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 132,
						"End": 142,
						"Line": 13,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 89,
				"End": 101,
				"Line": 10,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"OnCreatedObjectInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "OnCreatedObjectInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 462,
							"End": 464,
							"Line": 39,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 446,
						"End": 450,
						"Line": 38,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "id",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ID",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 472,
							"End": 482,
							"Line": 40,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 462,
						"End": 464,
						"Line": 39,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 489,
							"End": 490,
							"Line": 41,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 472,
						"End": 482,
						"Line": 40,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 421,
				"End": 441,
				"Line": 37,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"OnUpdatedObjectInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "OnUpdatedObjectInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 539,
							"End": 541,
							"Line": 45,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 523,
						"End": 527,
						"Line": 44,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "id",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ID",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 549,
							"End": 559,
							"Line": 46,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 539,
						"End": 541,
						"Line": 45,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 566,
							"End": 567,
							"Line": 47,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 549,
						"End": 559,
						"Line": 46,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 498,
				"End": 518,
				"Line": 43,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"PageInfo": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "PageInfo",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "endCursor",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ID",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 726,
							"End": 737,
							"Line": 61,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 709,
						"End": 718,
						"Line": 60,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "hasNextPage",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 748,
							"End": 749,
							"Line": 62,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 726,
						"End": 737,
						"Line": 61,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 696,
				"End": 704,
				"Line": 59,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"PageInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "PageInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "first",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Int",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 673,
							"End": 678,
							"Line": 56,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 659,
						"End": 664,
						"Line": 55,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "after",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 688,
							"End": 689,
							"Line": 57,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 673,
						"End": 678,
						"Line": 56,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 645,
				"End": 654,
				"Line": 54,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"Query": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "Query",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "objects",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 999,
									"End": 1000,
									"Line": 82,
									"Column": 28,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 982,
								"End": 994,
								"Line": 82,
								"Column": 11,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "Object",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1003,
								"End": 1009,
								"Line": 82,
								"Column": 32,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 1014,
							"End": 1026,
							"Line": 83,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 974,
						"End": 981,
						"Line": 82,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "objectRecord",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1046,
									"End": 1050,
									"Line": 83,
									"Column": 35,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1027,
								"End": 1039,
								"Line": 83,
								"Column": 16,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "name",
							"DefaultValue": null,
							"Type": {
								"NamedType": "String",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1061,
									"End": 1063,
									"Line": 83,
									"Column": 50,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1046,
								"End": 1050,
								"Line": 83,
								"Column": 35,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "id",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1068,
									"End": 1069,
									"Line": 83,
									"Column": 57,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1061,
								"End": 1063,
								"Line": 83,
								"Column": 50,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1087,
							"End": 1091,
							"Line": 84,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1014,
						"End": 1026,
						"Line": 83,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "soql",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1111,
									"End": 1112,
									"Line": 84,
									"Column": 27,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1092,
								"End": 1104,
								"Line": 84,
								"Column": 8,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "q",
							"DefaultValue": null,
							"Type": {
								"NamedType": "String",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1123,
									"End": 1128,
									"Line": 84,
									"Column": 39,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1111,
								"End": 1112,
								"Line": 84,
								"Column": 27,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "input",
							"DefaultValue": null,
							"Type": {
								"NamedType": "PageInput",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1140,
									"End": 1141,
									"Line": 84,
									"Column": 56,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1123,
								"End": 1128,
								"Line": 84,
								"Column": 39,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "QueryResult",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1158,
							"End": 1164,
							"Line": 85,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1087,
						"End": 1091,
						"Line": 84,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "health",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "ConnectorHealth",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1183,
							"End": 1184,
							"Line": 86,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1158,
						"End": 1164,
						"Line": 85,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "__schema",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Schema",
						"Elem": null,
						"NonNull": true,
						"Position": null
					},
					"Directives": null,
					"Position": null
				},
				{
					"Description": "",
					"Name": "__type",
					"Arguments": [
						{
							"Description": "",
							"Name": "name",
							"DefaultValue": null,
							"Type": {
								"NamedType": "String",
								"Elem": null,
								"NonNull": true,
								"Position": null
							},
							"Directives": null,
							"Position": null
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": false,
						"Position": null
					},
					"Directives": null,
					"Position": null
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 964,
				"End": 969,
				"Line": 81,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"QueryResult": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "QueryResult",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "edges",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "Edge",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 780,
								"End": 784,
								"Line": 65,
								"Column": 11,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 789,
							"End": 797,
							"Line": 66,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 772,
						"End": 777,
						"Line": 65,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "pageInfo",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "PageInfo",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 811,
							"End": 821,
							"Line": 67,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 789,
						"End": 797,
						"Line": 66,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "totalCount",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Int",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 828,
							"End": 829,
							"Line": 68,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 811,
						"End": 821,
						"Line": 67,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 756,
				"End": 767,
				"Line": 64,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"String": {
			"Kind": "SCALAR",
			"Description": "The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
			"Name": "String",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 650,
				"End": 656,
				"Line": 10,
				"Column": 8,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"Subscription": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "Subscription",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "objectRecordsCreated",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1876,
									"End": 1877,
									"Line": 114,
									"Column": 41,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1859,
								"End": 1871,
								"Line": 114,
								"Column": 24,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1880,
								"End": 1892,
								"Line": 114,
								"Column": 45,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 1897,
							"End": 1916,
							"Line": 115,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1838,
						"End": 1858,
						"Line": 114,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "objectRecordUpdated",
					"Arguments": [
						{
							"Description": "",
							"Name": "connectionId",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1936,
									"End": 1940,
									"Line": 115,
									"Column": 42,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1917,
								"End": 1929,
								"Line": 115,
								"Column": 23,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "name",
							"DefaultValue": null,
							"Type": {
								"NamedType": "String",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1951,
									"End": 1953,
									"Line": 115,
									"Column": 57,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1936,
								"End": 1940,
								"Line": 115,
								"Column": 42,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						{
							"Description": "",
							"Name": "id",
							"DefaultValue": null,
							"Type": {
								"NamedType": "ID",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1958,
									"End": 1959,
									"Line": 115,
									"Column": 64,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 1951,
								"End": 1953,
								"Line": 115,
								"Column": 57,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "ObjectRecord",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1975,
							"End": 1976,
							"Line": 116,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1897,
						"End": 1916,
						"Line": 115,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 1821,
				"End": 1833,
				"Line": 113,
				"Column": 6,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"UpdateObjectRecordInput": {
			"Kind": "INPUT_OBJECT",
			"Description": "",
			"Name": "UpdateObjectRecordInput",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 619,
							"End": 629,
							"Line": 51,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 603,
						"End": 607,
						"Line": 50,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				},
				{
					"Description": "",
					"Name": "properties",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Map",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 636,
							"End": 637,
							"Line": 52,
							"Column": 1,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 619,
						"End": 629,
						"Line": 51,
						"Column": 3,
						"Src": {
							"Name": "default",
							"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
							"BuiltIn": false
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 575,
				"End": 598,
				"Line": 49,
				"Column": 7,
				"Src": {
					"Name": "default",
					"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
					"BuiltIn": false
				}
			},
			"BuiltIn": false
		},
		"__Directive": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__Directive",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 3057,
							"End": 3068,
							"Line": 95,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 3039,
						"End": 3043,
						"Line": 94,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "description",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 3070,
							"End": 3076,
							"Line": 95,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 3057,
						"End": 3068,
						"Line": 95,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "locations",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__DirectiveLocation",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 3113,
								"End": 3114,
								"Line": 96,
								"Column": 37,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 3120,
							"End": 3124,
							"Line": 97,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 3081,
						"End": 3090,
						"Line": 96,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "args",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__InputValue",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 3140,
								"End": 3141,
								"Line": 97,
								"Column": 25,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 3147,
							"End": 3159,
							"Line": 98,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 3120,
						"End": 3124,
						"Line": 97,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "isRepeatable",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 3170,
							"End": 3171,
							"Line": 99,
							"Column": 1,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 3147,
						"End": 3159,
						"Line": 98,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 3021,
				"End": 3032,
				"Line": 93,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__DirectiveLocation": {
			"Kind": "ENUM",
			"Description": "",
			"Name": "__DirectiveLocation",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": [
				{
					"Description": "",
					"Name": "QUERY",
					"Directives": null,
					"Position": {
						"Start": 3204,
						"End": 3209,
						"Line": 102,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "MUTATION",
					"Directives": null,
					"Position": {
						"Start": 3214,
						"End": 3222,
						"Line": 103,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "SUBSCRIPTION",
					"Directives": null,
					"Position": {
						"Start": 3227,
						"End": 3239,
						"Line": 104,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "FIELD",
					"Directives": null,
					"Position": {
						"Start": 3244,
						"End": 3249,
						"Line": 105,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "FRAGMENT_DEFINITION",
					"Directives": null,
					"Position": {
						"Start": 3254,
						"End": 3273,
						"Line": 106,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "FRAGMENT_SPREAD",
					"Directives": null,
					"Position": {
						"Start": 3278,
						"End": 3293,
						"Line": 107,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INLINE_FRAGMENT",
					"Directives": null,
					"Position": {
						"Start": 3298,
						"End": 3313,
						"Line": 108,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "VARIABLE_DEFINITION",
					"Directives": null,
					"Position": {
						"Start": 3318,
						"End": 3337,
						"Line": 109,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "SCHEMA",
					"Directives": null,
					"Position": {
						"Start": 3342,
						"End": 3348,
						"Line": 110,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "SCALAR",
					"Directives": null,
					"Position": {
						"Start": 3353,
						"End": 3359,
						"Line": 111,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "OBJECT",
					"Directives": null,
					"Position": {
						"Start": 3364,
						"End": 3370,
						"Line": 112,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "FIELD_DEFINITION",
					"Directives": null,
					"Position": {
						"Start": 3375,
						"End": 3391,
						"Line": 113,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "ARGUMENT_DEFINITION",
					"Directives": null,
					"Position": {
						"Start": 3396,
						"End": 3415,
						"Line": 114,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INTERFACE",
					"Directives": null,
					"Position": {
						"Start": 3420,
						"End": 3429,
						"Line": 115,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "UNION",
					"Directives": null,
					"Position": {
						"Start": 3434,
						"End": 3439,
						"Line": 116,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "ENUM",
					"Directives": null,
					"Position": {
						"Start": 3444,
						"End": 3448,
						"Line": 117,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "ENUM_VALUE",
					"Directives": null,
					"Position": {
						"Start": 3453,
						"End": 3463,
						"Line": 118,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INPUT_OBJECT",
					"Directives": null,
					"Position": {
						"Start": 3468,
						"End": 3480,
						"Line": 119,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INPUT_FIELD_DEFINITION",
					"Directives": null,
					"Position": {
						"Start": 3485,
						"End": 3507,
						"Line": 120,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Position": {
				"Start": 3178,
				"End": 3197,
				"Line": 101,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__EnumValue": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__EnumValue",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2821,
							"End": 2832,
							"Line": 77,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2803,
						"End": 2807,
						"Line": 76,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "description",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2834,
							"End": 2840,
							"Line": 77,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2821,
						"End": 2832,
						"Line": 77,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "isDeprecated",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2872,
							"End": 2889,
							"Line": 79,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2845,
						"End": 2857,
						"Line": 78,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "deprecationReason",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2891,
							"End": 2897,
							"Line": 79,
							"Column": 24,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2872,
						"End": 2889,
						"Line": 79,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 2785,
				"End": 2796,
				"Line": 75,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__Field": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__Field",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2547,
							"End": 2558,
							"Line": 61,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2529,
						"End": 2533,
						"Line": 60,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "description",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2560,
							"End": 2566,
							"Line": 61,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2547,
						"End": 2558,
						"Line": 61,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "args",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__InputValue",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2591,
								"End": 2592,
								"Line": 62,
								"Column": 25,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 2598,
							"End": 2602,
							"Line": 63,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2571,
						"End": 2575,
						"Line": 62,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "type",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2616,
							"End": 2628,
							"Line": 64,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2598,
						"End": 2602,
						"Line": 63,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "isDeprecated",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2643,
							"End": 2660,
							"Line": 65,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2616,
						"End": 2628,
						"Line": 64,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "deprecationReason",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2662,
							"End": 2668,
							"Line": 65,
							"Column": 24,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2643,
						"End": 2660,
						"Line": 65,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 2515,
				"End": 2522,
				"Line": 59,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__InputValue": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__InputValue",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2714,
							"End": 2725,
							"Line": 70,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2696,
						"End": 2700,
						"Line": 69,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "description",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2727,
							"End": 2733,
							"Line": 70,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2714,
						"End": 2725,
						"Line": 70,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "type",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2756,
							"End": 2768,
							"Line": 72,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2738,
						"End": 2742,
						"Line": 71,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "defaultValue",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2770,
							"End": 2776,
							"Line": 72,
							"Column": 19,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2756,
						"End": 2768,
						"Line": 72,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 2677,
				"End": 2689,
				"Line": 68,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__Schema": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__Schema",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "types",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1926,
								"End": 1927,
								"Line": 28,
								"Column": 20,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 1933,
							"End": 1942,
							"Line": 29,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1911,
						"End": 1916,
						"Line": 28,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "queryType",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1956,
							"End": 1968,
							"Line": 30,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1933,
						"End": 1942,
						"Line": 29,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "mutationType",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1970,
							"End": 1976,
							"Line": 30,
							"Column": 19,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1956,
						"End": 1968,
						"Line": 30,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "subscriptionType",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1999,
							"End": 2005,
							"Line": 31,
							"Column": 23,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1981,
						"End": 1997,
						"Line": 31,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "directives",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__Directive",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2035,
								"End": 2036,
								"Line": 32,
								"Column": 30,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": true,
						"Position": {
							"Start": 2038,
							"End": 2039,
							"Line": 33,
							"Column": 1,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2010,
						"End": 2020,
						"Line": 32,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 1896,
				"End": 1904,
				"Line": 27,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__Type": {
			"Kind": "OBJECT",
			"Description": "",
			"Name": "__Type",
			"Directives": null,
			"Interfaces": null,
			"Fields": [
				{
					"Description": "",
					"Name": "kind",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__TypeKind",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 2081,
							"End": 2085,
							"Line": 37,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2059,
						"End": 2063,
						"Line": 36,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "name",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2087,
							"End": 2093,
							"Line": 37,
							"Column": 11,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2081,
						"End": 2085,
						"Line": 37,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "description",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2111,
							"End": 2117,
							"Line": 38,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2098,
						"End": 2109,
						"Line": 38,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "fields",
					"Arguments": [
						{
							"Description": "",
							"Name": "includeDeprecated",
							"DefaultValue": {
								"Raw": "false",
								"Children": null,
								"Kind": 5,
								"Position": {
									"Start": 2191,
									"End": 2196,
									"Line": 41,
									"Column": 41,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								},
								"Definition": null,
								"VariableDefinition": null,
								"ExpectedType": null
							},
							"Type": {
								"NamedType": "Boolean",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 2181,
									"End": 2188,
									"Line": 41,
									"Column": 31,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 2162,
								"End": 2179,
								"Line": 41,
								"Column": 12,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__Field",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2208,
								"End": 2209,
								"Line": 41,
								"Column": 58,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 2200,
							"End": 2207,
							"Line": 41,
							"Column": 50,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2155,
						"End": 2161,
						"Line": 41,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "interfaces",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2253,
								"End": 2254,
								"Line": 44,
								"Column": 25,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 2246,
							"End": 2252,
							"Line": 44,
							"Column": 18,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2233,
						"End": 2243,
						"Line": 44,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "possibleTypes",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2314,
								"End": 2315,
								"Line": 47,
								"Column": 28,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 2307,
							"End": 2313,
							"Line": 47,
							"Column": 21,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2291,
						"End": 2304,
						"Line": 47,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "enumValues",
					"Arguments": [
						{
							"Description": "",
							"Name": "includeDeprecated",
							"DefaultValue": {
								"Raw": "false",
								"Children": null,
								"Kind": 5,
								"Position": {
									"Start": 2377,
									"End": 2382,
									"Line": 50,
									"Column": 45,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								},
								"Definition": null,
								"VariableDefinition": null,
								"ExpectedType": null
							},
							"Type": {
								"NamedType": "Boolean",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 2367,
									"End": 2374,
									"Line": 50,
									"Column": 35,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"Directives": null,
							"Position": {
								"Start": 2348,
								"End": 2365,
								"Line": 50,
								"Column": 16,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						}
					],
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__EnumValue",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2398,
								"End": 2399,
								"Line": 50,
								"Column": 66,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 2386,
							"End": 2397,
							"Line": 50,
							"Column": 54,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2337,
						"End": 2347,
						"Line": 50,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "inputFields",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "",
						"Elem": {
							"NamedType": "__InputValue",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2456,
								"End": 2457,
								"Line": 53,
								"Column": 32,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"NonNull": false,
						"Position": {
							"Start": 2443,
							"End": 2455,
							"Line": 53,
							"Column": 19,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2429,
						"End": 2440,
						"Line": 53,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "ofType",
					"Arguments": null,
					"DefaultValue": null,
					"Type": {
						"NamedType": "__Type",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 2500,
							"End": 2506,
							"Line": 56,
							"Column": 13,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 2492,
						"End": 2498,
						"Line": 56,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Types": null,
			"EnumValues": null,
			"Position": {
				"Start": 2046,
				"End": 2052,
				"Line": 35,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		},
		"__TypeKind": {
			"Kind": "ENUM",
			"Description": "",
			"Name": "__TypeKind",
			"Directives": null,
			"Interfaces": null,
			"Fields": null,
			"Types": null,
			"EnumValues": [
				{
					"Description": "",
					"Name": "SCALAR",
					"Directives": null,
					"Position": {
						"Start": 2923,
						"End": 2929,
						"Line": 83,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "OBJECT",
					"Directives": null,
					"Position": {
						"Start": 2934,
						"End": 2940,
						"Line": 84,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INTERFACE",
					"Directives": null,
					"Position": {
						"Start": 2945,
						"End": 2954,
						"Line": 85,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "UNION",
					"Directives": null,
					"Position": {
						"Start": 2959,
						"End": 2964,
						"Line": 86,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "ENUM",
					"Directives": null,
					"Position": {
						"Start": 2969,
						"End": 2973,
						"Line": 87,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "INPUT_OBJECT",
					"Directives": null,
					"Position": {
						"Start": 2978,
						"End": 2990,
						"Line": 88,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "LIST",
					"Directives": null,
					"Position": {
						"Start": 2995,
						"End": 2999,
						"Line": 89,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				},
				{
					"Description": "",
					"Name": "NON_NULL",
					"Directives": null,
					"Position": {
						"Start": 3004,
						"End": 3012,
						"Line": 90,
						"Column": 5,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Position": {
				"Start": 2906,
				"End": 2916,
				"Line": 82,
				"Column": 6,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			},
			"BuiltIn": true
		}
	},
	"Directives": {
		"deprecated": {
			"Description": "The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.",
			"Name": "deprecated",
			"Arguments": [
				{
					"Description": "",
					"Name": "reason",
					"DefaultValue": {
						"Raw": "No longer supported",
						"Children": null,
						"Kind": 3,
						"Position": {
							"Start": 1834,
							"End": 1855,
							"Line": 25,
							"Column": 41,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						},
						"Definition": null,
						"VariableDefinition": null,
						"ExpectedType": null
					},
					"Type": {
						"NamedType": "String",
						"Elem": null,
						"NonNull": false,
						"Position": {
							"Start": 1825,
							"End": 1831,
							"Line": 25,
							"Column": 31,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1817,
						"End": 1823,
						"Line": 25,
						"Column": 23,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Locations": [
				"FIELD_DEFINITION",
				"ENUM_VALUE"
			],
			"IsRepeatable": false,
			"Position": {
				"Start": 1806,
				"End": 1816,
				"Line": 25,
				"Column": 12,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			}
		},
		"include": {
			"Description": "The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.",
			"Name": "include",
			"Arguments": [
				{
					"Description": "",
					"Name": "if",
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1289,
							"End": 1290,
							"Line": 19,
							"Column": 32,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1277,
						"End": 1279,
						"Line": 19,
						"Column": 20,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Locations": [
				"FIELD",
				"FRAGMENT_SPREAD",
				"INLINE_FRAGMENT"
			],
			"IsRepeatable": false,
			"Position": {
				"Start": 1269,
				"End": 1276,
				"Line": 19,
				"Column": 12,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			}
		},
		"skip": {
			"Description": "The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.",
			"Name": "skip",
			"Arguments": [
				{
					"Description": "",
					"Name": "if",
					"DefaultValue": null,
					"Type": {
						"NamedType": "Boolean",
						"Elem": null,
						"NonNull": true,
						"Position": {
							"Start": 1542,
							"End": 1543,
							"Line": 22,
							"Column": 29,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					"Directives": null,
					"Position": {
						"Start": 1530,
						"End": 1532,
						"Line": 22,
						"Column": 17,
						"Src": {
							"Name": "prelude.graphql",
							"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
							"BuiltIn": true
						}
					}
				}
			],
			"Locations": [
				"FIELD",
				"FRAGMENT_SPREAD",
				"INLINE_FRAGMENT"
			],
			"IsRepeatable": false,
			"Position": {
				"Start": 1525,
				"End": 1529,
				"Line": 22,
				"Column": 12,
				"Src": {
					"Name": "prelude.graphql",
					"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
					"BuiltIn": true
				}
			}
		}
	},
	"PossibleTypes": {
		"AuthInfoInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "AuthInfoInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "type",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 926,
								"End": 936,
								"Line": 77,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 910,
							"End": 914,
							"Line": 76,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 943,
								"End": 944,
								"Line": 78,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 926,
							"End": 936,
							"Line": 77,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 892,
					"End": 905,
					"Line": 75,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"ConnectorHealth": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "ConnectorHealth",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "status",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "HealthStatus",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 303,
								"End": 314,
								"Line": 28,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 279,
							"End": 285,
							"Line": 27,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "lastChecked",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Int",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 323,
								"End": 329,
								"Line": 29,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 303,
							"End": 314,
							"Line": 28,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "errors",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "HealthError",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 332,
									"End": 343,
									"Line": 29,
									"Column": 12,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 332,
								"End": 343,
								"Line": 29,
								"Column": 12,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 323,
							"End": 329,
							"Line": 29,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 259,
					"End": 274,
					"Line": 26,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"Edge": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "Edge",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "cursor",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 863,
								"End": 867,
								"Line": 72,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 845,
							"End": 851,
							"Line": 71,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "node",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 883,
								"End": 884,
								"Line": 73,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 863,
							"End": 867,
							"Line": 72,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 836,
					"End": 840,
					"Line": 70,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"HealthError": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "HealthError",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "test",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 234,
								"End": 241,
								"Line": 23,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 218,
							"End": 222,
							"Line": 22,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "message",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 251,
								"End": 252,
								"Line": 24,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 234,
							"End": 241,
							"Line": 23,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 202,
					"End": 213,
					"Line": 21,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"Mutation": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "Mutation",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "registerConnection",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1242,
										"End": 1247,
										"Line": 89,
										"Column": 41,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1223,
									"End": 1235,
									"Line": 89,
									"Column": 22,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "AuthInfoInput",
									"Elem": null,
									"NonNull": false,
									"Position": {
										"Start": 1249,
										"End": 1262,
										"Line": 89,
										"Column": 48,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1242,
									"End": 1247,
									"Line": 89,
									"Column": 41,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1265,
								"End": 1268,
								"Line": 89,
								"Column": 64,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1204,
							"End": 1222,
							"Line": 89,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "revokeConnection",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1305,
										"End": 1306,
										"Line": 90,
										"Column": 37,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1288,
									"End": 1300,
									"Line": 90,
									"Column": 20,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1308,
								"End": 1311,
								"Line": 90,
								"Column": 40,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1271,
							"End": 1287,
							"Line": 90,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "createObjectRecord",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1360,
										"End": 1365,
										"Line": 93,
										"Column": 5,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1338,
									"End": 1350,
									"Line": 92,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "NewObjectRecordInput",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1391,
										"End": 1392,
										"Line": 94,
										"Column": 3,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1360,
									"End": 1365,
									"Line": 93,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1410,
								"End": 1428,
								"Line": 95,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1314,
							"End": 1332,
							"Line": 91,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "updateObjectRecord",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1456,
										"End": 1458,
										"Line": 97,
										"Column": 5,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1434,
									"End": 1446,
									"Line": 96,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "id",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1468,
										"End": 1473,
										"Line": 98,
										"Column": 5,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1456,
									"End": 1458,
									"Line": 97,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "UpdateObjectRecordInput",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1502,
										"End": 1503,
										"Line": 99,
										"Column": 3,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1468,
									"End": 1473,
									"Line": 98,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1521,
								"End": 1543,
								"Line": 100,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1410,
							"End": 1428,
							"Line": 95,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "onObjectRecordsCreated",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1571,
										"End": 1576,
										"Line": 102,
										"Column": 5,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1549,
									"End": 1561,
									"Line": 101,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "",
									"Elem": {
										"NamedType": "OnCreatedObjectInput",
										"Elem": null,
										"NonNull": true,
										"Position": {
											"Start": 1600,
											"End": 1601,
											"Line": 102,
											"Column": 34,
											"Src": {
												"Name": "default",
												"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
												"BuiltIn": false
											}
										}
									},
									"NonNull": true,
									"Position": {
										"Start": 1605,
										"End": 1606,
										"Line": 103,
										"Column": 3,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1571,
									"End": 1576,
									"Line": 102,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1608,
								"End": 1611,
								"Line": 103,
								"Column": 6,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1521,
							"End": 1543,
							"Line": 100,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "onObjectRecordsUpdated",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1664,
										"End": 1669,
										"Line": 106,
										"Column": 5,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1642,
									"End": 1654,
									"Line": 105,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "",
									"Elem": {
										"NamedType": "OnUpdatedObjectInput",
										"Elem": null,
										"NonNull": true,
										"Position": {
											"Start": 1693,
											"End": 1694,
											"Line": 106,
											"Column": 34,
											"Src": {
												"Name": "default",
												"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
												"BuiltIn": false
											}
										}
									},
									"NonNull": true,
									"Position": {
										"Start": 1698,
										"End": 1699,
										"Line": 107,
										"Column": 3,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1664,
									"End": 1669,
									"Line": 106,
									"Column": 5,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1701,
								"End": 1704,
								"Line": 107,
								"Column": 6,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1614,
							"End": 1636,
							"Line": 104,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "pollForChange",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1738,
										"End": 1739,
										"Line": 108,
										"Column": 34,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1721,
									"End": 1733,
									"Line": 108,
									"Column": 17,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1741,
								"End": 1744,
								"Line": 108,
								"Column": 37,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1707,
							"End": 1720,
							"Line": 108,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "keepTokenAlive",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1779,
										"End": 1780,
										"Line": 109,
										"Column": 35,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1762,
									"End": 1774,
									"Line": 109,
									"Column": 18,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1782,
								"End": 1785,
								"Line": 109,
								"Column": 38,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1747,
							"End": 1761,
							"Line": 109,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "runIntegrationTests",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Any",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1809,
								"End": 1812,
								"Line": 110,
								"Column": 24,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1788,
							"End": 1807,
							"Line": 110,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 1191,
					"End": 1199,
					"Line": 88,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"NewObjectRecordInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "NewObjectRecordInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 395,
								"End": 405,
								"Line": 34,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 379,
							"End": 383,
							"Line": 33,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 412,
								"End": 413,
								"Line": 35,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 395,
							"End": 405,
							"Line": 34,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 354,
					"End": 374,
					"Line": 32,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"Object": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "Object",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 64,
								"End": 74,
								"Line": 7,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 48,
							"End": 52,
							"Line": 6,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 81,
								"End": 82,
								"Line": 8,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 64,
							"End": 74,
							"Line": 7,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 37,
					"End": 43,
					"Line": 5,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"ObjectRecord": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "ObjectRecord",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "id",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 116,
								"End": 120,
								"Line": 12,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 106,
							"End": 108,
							"Line": 11,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "type",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 132,
								"End": 142,
								"Line": 13,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 116,
							"End": 120,
							"Line": 12,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 149,
								"End": 150,
								"Line": 14,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 132,
							"End": 142,
							"Line": 13,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 89,
					"End": 101,
					"Line": 10,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"OnCreatedObjectInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "OnCreatedObjectInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 462,
								"End": 464,
								"Line": 39,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 446,
							"End": 450,
							"Line": 38,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "id",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 472,
								"End": 482,
								"Line": 40,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 462,
							"End": 464,
							"Line": 39,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 489,
								"End": 490,
								"Line": 41,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 472,
							"End": 482,
							"Line": 40,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 421,
					"End": 441,
					"Line": 37,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"OnUpdatedObjectInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "OnUpdatedObjectInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 539,
								"End": 541,
								"Line": 45,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 523,
							"End": 527,
							"Line": 44,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "id",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 549,
								"End": 559,
								"Line": 46,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 539,
							"End": 541,
							"Line": 45,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 566,
								"End": 567,
								"Line": 47,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 549,
							"End": 559,
							"Line": 46,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 498,
					"End": 518,
					"Line": 43,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"PageInfo": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "PageInfo",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "endCursor",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ID",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 726,
								"End": 737,
								"Line": 61,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 709,
							"End": 718,
							"Line": 60,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "hasNextPage",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Boolean",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 748,
								"End": 749,
								"Line": 62,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 726,
							"End": 737,
							"Line": 61,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 696,
					"End": 704,
					"Line": 59,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"PageInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "PageInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "first",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Int",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 673,
								"End": 678,
								"Line": 56,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 659,
							"End": 664,
							"Line": 55,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "after",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 688,
								"End": 689,
								"Line": 57,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 673,
							"End": 678,
							"Line": 56,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 645,
					"End": 654,
					"Line": 54,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"Query": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "Query",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "objects",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 999,
										"End": 1000,
										"Line": 82,
										"Column": 28,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 982,
									"End": 994,
									"Line": 82,
									"Column": 11,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "Object",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 1003,
									"End": 1009,
									"Line": 82,
									"Column": 32,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 1014,
								"End": 1026,
								"Line": 83,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 974,
							"End": 981,
							"Line": 82,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "objectRecord",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1046,
										"End": 1050,
										"Line": 83,
										"Column": 35,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1027,
									"End": 1039,
									"Line": 83,
									"Column": 16,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "name",
								"DefaultValue": null,
								"Type": {
									"NamedType": "String",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1061,
										"End": 1063,
										"Line": 83,
										"Column": 50,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1046,
									"End": 1050,
									"Line": 83,
									"Column": 35,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "id",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1068,
										"End": 1069,
										"Line": 83,
										"Column": 57,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1061,
									"End": 1063,
									"Line": 83,
									"Column": 50,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1087,
								"End": 1091,
								"Line": 84,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1014,
							"End": 1026,
							"Line": 83,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "soql",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1111,
										"End": 1112,
										"Line": 84,
										"Column": 27,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1092,
									"End": 1104,
									"Line": 84,
									"Column": 8,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "q",
								"DefaultValue": null,
								"Type": {
									"NamedType": "String",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1123,
										"End": 1128,
										"Line": 84,
										"Column": 39,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1111,
									"End": 1112,
									"Line": 84,
									"Column": 27,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "input",
								"DefaultValue": null,
								"Type": {
									"NamedType": "PageInput",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1140,
										"End": 1141,
										"Line": 84,
										"Column": 56,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1123,
									"End": 1128,
									"Line": 84,
									"Column": 39,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "QueryResult",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1158,
								"End": 1164,
								"Line": 85,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1087,
							"End": 1091,
							"Line": 84,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "health",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "ConnectorHealth",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1183,
								"End": 1184,
								"Line": 86,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1158,
							"End": 1164,
							"Line": 85,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "__schema",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Schema",
							"Elem": null,
							"NonNull": true,
							"Position": null
						},
						"Directives": null,
						"Position": null
					},
					{
						"Description": "",
						"Name": "__type",
						"Arguments": [
							{
								"Description": "",
								"Name": "name",
								"DefaultValue": null,
								"Type": {
									"NamedType": "String",
									"Elem": null,
									"NonNull": true,
									"Position": null
								},
								"Directives": null,
								"Position": null
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": false,
							"Position": null
						},
						"Directives": null,
						"Position": null
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 964,
					"End": 969,
					"Line": 81,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"QueryResult": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "QueryResult",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "edges",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "Edge",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 780,
									"End": 784,
									"Line": 65,
									"Column": 11,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 789,
								"End": 797,
								"Line": 66,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 772,
							"End": 777,
							"Line": 65,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "pageInfo",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "PageInfo",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 811,
								"End": 821,
								"Line": 67,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 789,
							"End": 797,
							"Line": 66,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "totalCount",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Int",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 828,
								"End": 829,
								"Line": 68,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 811,
							"End": 821,
							"Line": 67,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 756,
					"End": 767,
					"Line": 64,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"Subscription": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "Subscription",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "objectRecordsCreated",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1876,
										"End": 1877,
										"Line": 114,
										"Column": 41,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1859,
									"End": 1871,
									"Line": 114,
									"Column": 24,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "ObjectRecord",
								"Elem": null,
								"NonNull": false,
								"Position": {
									"Start": 1880,
									"End": 1892,
									"Line": 114,
									"Column": 45,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 1897,
								"End": 1916,
								"Line": 115,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1838,
							"End": 1858,
							"Line": 114,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "objectRecordUpdated",
						"Arguments": [
							{
								"Description": "",
								"Name": "connectionId",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1936,
										"End": 1940,
										"Line": 115,
										"Column": 42,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1917,
									"End": 1929,
									"Line": 115,
									"Column": 23,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "name",
								"DefaultValue": null,
								"Type": {
									"NamedType": "String",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1951,
										"End": 1953,
										"Line": 115,
										"Column": 57,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1936,
									"End": 1940,
									"Line": 115,
									"Column": 42,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							},
							{
								"Description": "",
								"Name": "id",
								"DefaultValue": null,
								"Type": {
									"NamedType": "ID",
									"Elem": null,
									"NonNull": true,
									"Position": {
										"Start": 1958,
										"End": 1959,
										"Line": 115,
										"Column": 64,
										"Src": {
											"Name": "default",
											"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
											"BuiltIn": false
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 1951,
									"End": 1953,
									"Line": 115,
									"Column": 57,
									"Src": {
										"Name": "default",
										"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
										"BuiltIn": false
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "ObjectRecord",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1975,
								"End": 1976,
								"Line": 116,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1897,
							"End": 1916,
							"Line": 115,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 1821,
					"End": 1833,
					"Line": 113,
					"Column": 6,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"UpdateObjectRecordInput": [
			{
				"Kind": "INPUT_OBJECT",
				"Description": "",
				"Name": "UpdateObjectRecordInput",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 619,
								"End": 629,
								"Line": 51,
								"Column": 3,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 603,
							"End": 607,
							"Line": 50,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					},
					{
						"Description": "",
						"Name": "properties",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Map",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 636,
								"End": 637,
								"Line": 52,
								"Column": 1,
								"Src": {
									"Name": "default",
									"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
									"BuiltIn": false
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 619,
							"End": 629,
							"Line": 51,
							"Column": 3,
							"Src": {
								"Name": "default",
								"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
								"BuiltIn": false
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 575,
					"End": 598,
					"Line": 49,
					"Column": 7,
					"Src": {
						"Name": "default",
						"Input": "scalar Any\nscalar Map\n\n# Schema\ntype Object {\n  name: String!\n  properties: Map!\n}\n\ntype ObjectRecord {\n  id: ID!\n  type: String!\n  properties: Map!\n}\n\nenum HealthStatus {\n  HEALTHY\n  UNHEALTHY\n}\n\ntype HealthError {\n  test: String!\n  message: String!\n}\n\ntype ConnectorHealth {\n  status: HealthStatus!\n  lastChecked: Int!\n  errors: [HealthError]\n}\n\ninput NewObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput OnCreatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput OnUpdatedObjectInput {\n  name: String!\n  id: ID!\n  properties: Map!\n}\n\ninput UpdateObjectRecordInput {\n  name: String!\n  properties: Map!\n}\n\ninput PageInput {\n  first: Int!\n  after: String!\n}\n\ntype PageInfo {\n  endCursor: ID!\n  hasNextPage: Boolean!\n}\n\ntype QueryResult {\n  edges: [Edge]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype Edge {\n  cursor: String!\n  node: ObjectRecord!\n}\n\ninput AuthInfoInput {\n  type: String!\n  properties: Map!\n}\n\n# Operations\ntype Query {\n  objects(connectionId: ID!): [Object]!\n  objectRecord(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n  soql(connectionId: ID!, q: String!, input: PageInput!): QueryResult!\n  health: ConnectorHealth!\n}\n\ntype Mutation {\n  registerConnection(connectionId: ID!, input: AuthInfoInput): Any\n  revokeConnection(connectionId: ID!): Any\n  createObjectRecord(\n    connectionId: ID!\n    input: NewObjectRecordInput!\n  ): ObjectRecord!\n  updateObjectRecord(\n    connectionId: ID!\n    id: ID!\n    input: UpdateObjectRecordInput!\n  ): ObjectRecord!\n  onObjectRecordsCreated(\n    connectionId: ID!\n    input: [OnCreatedObjectInput!]!\n  ): Any\n  onObjectRecordsUpdated(\n    connectionId: ID!\n    input: [OnUpdatedObjectInput!]!\n  ): Any\n  pollForChange(connectionId: ID!): Any\n  keepTokenAlive(connectionId: ID!): Any\n  runIntegrationTests: Any\n}\n\ntype Subscription {\n  objectRecordsCreated(connectionId: ID!): [ObjectRecord]!\n  objectRecordUpdated(connectionId: ID!, name: String!, id: ID!): ObjectRecord!\n}\n",
						"BuiltIn": false
					}
				},
				"BuiltIn": false
			}
		],
		"__Directive": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__Directive",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 3057,
								"End": 3068,
								"Line": 95,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 3039,
							"End": 3043,
							"Line": 94,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "description",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 3070,
								"End": 3076,
								"Line": 95,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 3057,
							"End": 3068,
							"Line": 95,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "locations",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__DirectiveLocation",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 3113,
									"End": 3114,
									"Line": 96,
									"Column": 37,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 3120,
								"End": 3124,
								"Line": 97,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 3081,
							"End": 3090,
							"Line": 96,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "args",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__InputValue",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 3140,
									"End": 3141,
									"Line": 97,
									"Column": 25,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 3147,
								"End": 3159,
								"Line": 98,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 3120,
							"End": 3124,
							"Line": 97,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "isRepeatable",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Boolean",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 3170,
								"End": 3171,
								"Line": 99,
								"Column": 1,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 3147,
							"End": 3159,
							"Line": 98,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 3021,
					"End": 3032,
					"Line": 93,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		],
		"__EnumValue": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__EnumValue",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2821,
								"End": 2832,
								"Line": 77,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2803,
							"End": 2807,
							"Line": 76,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "description",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2834,
								"End": 2840,
								"Line": 77,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2821,
							"End": 2832,
							"Line": 77,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "isDeprecated",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Boolean",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2872,
								"End": 2889,
								"Line": 79,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2845,
							"End": 2857,
							"Line": 78,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "deprecationReason",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2891,
								"End": 2897,
								"Line": 79,
								"Column": 24,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2872,
							"End": 2889,
							"Line": 79,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 2785,
					"End": 2796,
					"Line": 75,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		],
		"__Field": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__Field",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2547,
								"End": 2558,
								"Line": 61,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2529,
							"End": 2533,
							"Line": 60,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "description",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2560,
								"End": 2566,
								"Line": 61,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2547,
							"End": 2558,
							"Line": 61,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "args",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__InputValue",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2591,
									"End": 2592,
									"Line": 62,
									"Column": 25,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 2598,
								"End": 2602,
								"Line": 63,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2571,
							"End": 2575,
							"Line": 62,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "type",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2616,
								"End": 2628,
								"Line": 64,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2598,
							"End": 2602,
							"Line": 63,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "isDeprecated",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "Boolean",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2643,
								"End": 2660,
								"Line": 65,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2616,
							"End": 2628,
							"Line": 64,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "deprecationReason",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2662,
								"End": 2668,
								"Line": 65,
								"Column": 24,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2643,
							"End": 2660,
							"Line": 65,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 2515,
					"End": 2522,
					"Line": 59,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		],
		"__InputValue": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__InputValue",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2714,
								"End": 2725,
								"Line": 70,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2696,
							"End": 2700,
							"Line": 69,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "description",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2727,
								"End": 2733,
								"Line": 70,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2714,
							"End": 2725,
							"Line": 70,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "type",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2756,
								"End": 2768,
								"Line": 72,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2738,
							"End": 2742,
							"Line": 71,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "defaultValue",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2770,
								"End": 2776,
								"Line": 72,
								"Column": 19,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2756,
							"End": 2768,
							"Line": 72,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 2677,
					"End": 2689,
					"Line": 68,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		],
		"__Schema": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__Schema",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "types",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__Type",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 1926,
									"End": 1927,
									"Line": 28,
									"Column": 20,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 1933,
								"End": 1942,
								"Line": 29,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1911,
							"End": 1916,
							"Line": 28,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "queryType",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 1956,
								"End": 1968,
								"Line": 30,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1933,
							"End": 1942,
							"Line": 29,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "mutationType",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1970,
								"End": 1976,
								"Line": 30,
								"Column": 19,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1956,
							"End": 1968,
							"Line": 30,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "subscriptionType",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 1999,
								"End": 2005,
								"Line": 31,
								"Column": 23,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 1981,
							"End": 1997,
							"Line": 31,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "directives",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__Directive",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2035,
									"End": 2036,
									"Line": 32,
									"Column": 30,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": true,
							"Position": {
								"Start": 2038,
								"End": 2039,
								"Line": 33,
								"Column": 1,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2010,
							"End": 2020,
							"Line": 32,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 1896,
					"End": 1904,
					"Line": 27,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		],
		"__Type": [
			{
				"Kind": "OBJECT",
				"Description": "",
				"Name": "__Type",
				"Directives": null,
				"Interfaces": null,
				"Fields": [
					{
						"Description": "",
						"Name": "kind",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__TypeKind",
							"Elem": null,
							"NonNull": true,
							"Position": {
								"Start": 2081,
								"End": 2085,
								"Line": 37,
								"Column": 5,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2059,
							"End": 2063,
							"Line": 36,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "name",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2087,
								"End": 2093,
								"Line": 37,
								"Column": 11,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2081,
							"End": 2085,
							"Line": 37,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "description",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "String",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2111,
								"End": 2117,
								"Line": 38,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2098,
							"End": 2109,
							"Line": 38,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "fields",
						"Arguments": [
							{
								"Description": "",
								"Name": "includeDeprecated",
								"DefaultValue": {
									"Raw": "false",
									"Children": null,
									"Kind": 5,
									"Position": {
										"Start": 2191,
										"End": 2196,
										"Line": 41,
										"Column": 41,
										"Src": {
											"Name": "prelude.graphql",
											"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
											"BuiltIn": true
										}
									},
									"Definition": null,
									"VariableDefinition": null,
									"ExpectedType": null
								},
								"Type": {
									"NamedType": "Boolean",
									"Elem": null,
									"NonNull": false,
									"Position": {
										"Start": 2181,
										"End": 2188,
										"Line": 41,
										"Column": 31,
										"Src": {
											"Name": "prelude.graphql",
											"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
											"BuiltIn": true
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 2162,
									"End": 2179,
									"Line": 41,
									"Column": 12,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__Field",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2208,
									"End": 2209,
									"Line": 41,
									"Column": 58,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 2200,
								"End": 2207,
								"Line": 41,
								"Column": 50,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2155,
							"End": 2161,
							"Line": 41,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "interfaces",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__Type",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2253,
									"End": 2254,
									"Line": 44,
									"Column": 25,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 2246,
								"End": 2252,
								"Line": 44,
								"Column": 18,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2233,
							"End": 2243,
							"Line": 44,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "possibleTypes",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__Type",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2314,
									"End": 2315,
									"Line": 47,
									"Column": 28,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 2307,
								"End": 2313,
								"Line": 47,
								"Column": 21,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2291,
							"End": 2304,
							"Line": 47,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "enumValues",
						"Arguments": [
							{
								"Description": "",
								"Name": "includeDeprecated",
								"DefaultValue": {
									"Raw": "false",
									"Children": null,
									"Kind": 5,
									"Position": {
										"Start": 2377,
										"End": 2382,
										"Line": 50,
										"Column": 45,
										"Src": {
											"Name": "prelude.graphql",
											"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
											"BuiltIn": true
										}
									},
									"Definition": null,
									"VariableDefinition": null,
									"ExpectedType": null
								},
								"Type": {
									"NamedType": "Boolean",
									"Elem": null,
									"NonNull": false,
									"Position": {
										"Start": 2367,
										"End": 2374,
										"Line": 50,
										"Column": 35,
										"Src": {
											"Name": "prelude.graphql",
											"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
											"BuiltIn": true
										}
									}
								},
								"Directives": null,
								"Position": {
									"Start": 2348,
									"End": 2365,
									"Line": 50,
									"Column": 16,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							}
						],
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__EnumValue",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2398,
									"End": 2399,
									"Line": 50,
									"Column": 66,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 2386,
								"End": 2397,
								"Line": 50,
								"Column": 54,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2337,
							"End": 2347,
							"Line": 50,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "inputFields",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "",
							"Elem": {
								"NamedType": "__InputValue",
								"Elem": null,
								"NonNull": true,
								"Position": {
									"Start": 2456,
									"End": 2457,
									"Line": 53,
									"Column": 32,
									"Src": {
										"Name": "prelude.graphql",
										"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
										"BuiltIn": true
									}
								}
							},
							"NonNull": false,
							"Position": {
								"Start": 2443,
								"End": 2455,
								"Line": 53,
								"Column": 19,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2429,
							"End": 2440,
							"Line": 53,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					},
					{
						"Description": "",
						"Name": "ofType",
						"Arguments": null,
						"DefaultValue": null,
						"Type": {
							"NamedType": "__Type",
							"Elem": null,
							"NonNull": false,
							"Position": {
								"Start": 2500,
								"End": 2506,
								"Line": 56,
								"Column": 13,
								"Src": {
									"Name": "prelude.graphql",
									"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
									"BuiltIn": true
								}
							}
						},
						"Directives": null,
						"Position": {
							"Start": 2492,
							"End": 2498,
							"Line": 56,
							"Column": 5,
							"Src": {
								"Name": "prelude.graphql",
								"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
								"BuiltIn": true
							}
						}
					}
				],
				"Types": null,
				"EnumValues": null,
				"Position": {
					"Start": 2046,
					"End": 2052,
					"Line": 35,
					"Column": 6,
					"Src": {
						"Name": "prelude.graphql",
						"Input": "# This file defines all the implicitly declared types that are required by the graphql spec. It is implicitly included by calls to LoadSchema\n\n\"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\"\nscalar Int\n\n\"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).\"\nscalar Float\n\n\"The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\"\nscalar String\n\n\"The `Boolean` scalar type represents `true` or `false`.\"\nscalar Boolean\n\n\"\"\"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \"4\") or integer (such as 4) input value will be accepted as an ID.\"\"\"\nscalar ID\n\n\"The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.\"\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.\"\ndirective @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n\n\"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL services schema, such as deprecated fields on a type or deprecated enum values.\"\ndirective @deprecated(reason: String = \"No longer supported\") on FIELD_DEFINITION | ENUM_VALUE\n\ntype __Schema {\n    types: [__Type!]!\n    queryType: __Type!\n    mutationType: __Type\n    subscriptionType: __Type\n    directives: [__Directive!]!\n}\n\ntype __Type {\n    kind: __TypeKind!\n    name: String\n    description: String\n\n    # OBJECT and INTERFACE only\n    fields(includeDeprecated: Boolean = false): [__Field!]\n\n    # OBJECT only\n    interfaces: [__Type!]\n\n    # INTERFACE and UNION only\n    possibleTypes: [__Type!]\n\n    # ENUM only\n    enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n\n    # INPUT_OBJECT only\n    inputFields: [__InputValue!]\n\n    # NON_NULL and LIST only\n    ofType: __Type\n}\n\ntype __Field {\n    name: String!\n    description: String\n    args: [__InputValue!]!\n    type: __Type!\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\ntype __InputValue {\n    name: String!\n    description: String\n    type: __Type!\n    defaultValue: String\n}\n\ntype __EnumValue {\n    name: String!\n    description: String\n    isDeprecated: Boolean!\n    deprecationReason: String\n}\n\nenum __TypeKind {\n    SCALAR\n    OBJECT\n    INTERFACE\n    UNION\n    ENUM\n    INPUT_OBJECT\n    LIST\n    NON_NULL\n}\n\ntype __Directive {\n    name: String!\n    description: String\n    locations: [__DirectiveLocation!]!\n    args: [__InputValue!]!\n    isRepeatable: Boolean!\n}\n\nenum __DirectiveLocation {\n    QUERY\n    MUTATION\n    SUBSCRIPTION\n    FIELD\n    FRAGMENT_DEFINITION\n    FRAGMENT_SPREAD\n    INLINE_FRAGMENT\n    VARIABLE_DEFINITION\n    SCHEMA\n    SCALAR\n    OBJECT\n    FIELD_DEFINITION\n    ARGUMENT_DEFINITION\n    INTERFACE\n    UNION\n    ENUM\n    ENUM_VALUE\n    INPUT_OBJECT\n    INPUT_FIELD_DEFINITION\n}\n",
						"BuiltIn": true
					}
				},
				"BuiltIn": true
			}
		]
	},
	"Implements": {}
}
